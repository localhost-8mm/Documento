
1. Write a simulation program to implement demand paging using LFU page replacement 
algorithm. Assume the memory of “n” frames. Show the contents of page after every page 
replacement in a frame and it at end we told number of page faults accordingly. Input the 
following page reference string: Page reference string : 3,4,5,4,3,4,7,2,4,5,6,7,2,4,6  
 
#include<stdio.h> 
#define MAX 20 
 
int frames[MAX],ref[MAX],mem[MAX][MAX],faults, 
 sp,m,n,count[MAX]; 
 
void accept() 
{ 
 int i; 
 
 printf("Enter no.of frames:"); 
 scanf("%d", &n); 
 
 printf("Enter no.of references:"); 
 scanf("%d", &m); 
 
 printf("Enter reference string:\n"); 
 for(i=0;i<m;i++) 
 { 
  printf("[%d]=",i); 
  scanf("%d",&ref[i]); 
 } 
} 
 
void disp() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
  printf("%3d",ref[i]); 
 
 printf("\n\n"); 
 
 for(i=0;i<n;i++) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(mem[i][j]) 
    printf("%3d",mem[i][j]); 
   else 
    printf("   "); 
  } 
  printf("\n"); 
 } 
 
 printf("Total Page Faults: %d\n",faults); 
} 
 
int search(int pno) 
{ 
 int i; 
 
 for(i=0;i<n;i++) 
 { 
  if(frames[i]==pno) 
   return i; 
 } 
 
 return -1; 
} 
 
int get_lfu(int sp) 
{ 
 int i,min_i,min=9999; 
 
 i=sp; 
 do 
 { 
  if(count[i]<min) 
  { 
   min = count[i]; 
   min_i = i; 
  } 
  i=(i+1)%n; 
 }while(i!=sp); 
 
 return min_i; 
} 
 
 
void lfu() 
{ 
 int i,j,k; 
 
 for(i=0;i<m && sp<n;i++) 
 { 
  k=search(ref[i]); 
  if(k==-1) 
  { 
   frames[sp]=ref[i]; 
   count[sp]++; 
   faults++; 
   sp++; 
 
   for(j=0;j<n;j++) 
    mem[j][i]=frames[j]; 
  } 
  else 
   count[k]++; 
   
 } 
 
 sp=0; 
 for(;i<m;i++) 
 { 
  k = search(ref[i]); 
  if(k==-1) 
  { 
   sp = get_lfu(sp); 
   frames[sp] = ref[i]; 
   count[sp]=1; 
   faults++; 
   sp = (sp+1)%n; 
 
   for(j=0;j<n;j++) 
    mem[j][i] = frames[j]; 
  } 
  else 
   count[k]++; 
 } 
} 
       
 
int main() 
{ 
 accept(); 
 lfu(); 
 disp(); 
 
 return 0; 
} 
 
2 Write a simulation program to implement Round Robin CPU scheduling algorithm for the given 
time quantum as input. Also accept the number of processes and arrival time and CPU burst time for 
each process as input. The output should give the Gant Chart, turnaround time and waiting time for 
each process. Also display the average turnaround time and average waiting time.  
 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
 
typedef struct process_info 
{ 
 char pname[20]; 
 int at,bt,ct,bt1; 
 struct process_info *next; 
}NODE; 
 
int n,ts; 
NODE *first,*last; 
 
void accept_info() 
{ 
 NODE *p; 
 int i; 
 
 printf("Enter no.of process:"); 
 scanf("%d",&n); 
 
 for(i=0;i<n;i++) 
 { 
  p = (NODE*)malloc(sizeof(NODE)); 
 
  printf("Enter process name:"); 
  scanf("%s",p->pname); 
 
  printf("Enter arrival time:"); 
  scanf("%d",&p->at); 
 
  printf("Enter first CPU burst time:"); 
  scanf("%d",&p->bt); 
 
  p->bt1 = p->bt; 
   
  p->next = NULL; 
 
  if(first==NULL) 
   first=p; 
  else 
   last->next=p; 
 
  last = p; 
 } 
 
 printf("Enter time slice:"); 
 scanf("%d",&ts); 
} 
 
void print_output() 
{ 
 NODE *p; 
 float avg_tat=0,avg_wt=0; 
 
 printf("pname\tat\tbt\tct\ttat\twt\n"); 
 
 p = first; 
 while(p!=NULL) 
 { 
  int tat = p->ct-p->at; 
  int wt = tat-p->bt; 
   
  avg_tat+=tat; 
  avg_wt+=wt; 
 
  printf("%s\t%d\t%d\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt,p->ct,tat,wt); 
   
  p=p->next; 
 } 
 
 printf("Avg TAT=%f\tAvg WT=%f\n", 
   avg_tat/n,avg_wt/n); 
} 
 
void print_input() 
{ 
 NODE *p; 
 
 p = first; 
  
 printf("pname\tat\tbt\n"); 
 while(p!=NULL) 
 { 
  printf("%s\t%d\t%d\n", 
   p->pname,p->at,p->bt1); 
  p = p->next; 
 } 
} 
 
void sort() 
{ 
 NODE *p,*q; 
 int t; 
 char name[20]; 
 
 p = first; 
 while(p->next!=NULL) 
 { 
  q=p->next; 
  while(q!=NULL) 
  { 
   if(p->at > q->at) 
   { 
    strcpy(name,p->pname); 
    strcpy(p->pname,q->pname); 
    strcpy(q->pname,name); 
 
    t = p->at; 
    p->at = q->at; 
    q->at = t; 
     
    t = p->bt; 
    p->bt = q->bt; 
    q->bt = t; 
 
    t = p->ct; 
    p->ct = q->ct; 
    q->ct = t; 
 
    t = p->bt1; 
    p->bt1 = q->bt1; 
    q->bt1 = t; 
   } 
 
   q=q->next; 
  } 
  
  p=p->next; 
 } 
} 
 
int time; 
 
int is_arrived() 
{ 
 NODE *p; 
 
 p = first; 
 while(p!=NULL) 
 { 
  if(p->at<=time && p->bt1!=0) 
   return 1; 
 
  p=p->next; 
 } 
 
 return 0; 
} 
 
NODE * delq() 
{ 
 NODE *t; 
 
 t = first; 
 first = first->next; 
 t->next=NULL; 
 
 return t; 
} 
 
void addq(NODE *t) 
{ 
 last->next = t; 
 last = t; 
} 
 
struct gantt_chart 
{ 
 int start; 
 char pname[30]; 
 int end; 
}s[100],s1[100]; 
 
int k; 
 
void rr() 
{ 
 int prev=0,n1=0; 
 NODE *p; 
 
 while(n1!=n) 
 { 
  if(!is_arrived()) 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname,"*"); 
   s[k].end = time; 
   k++; 
   prev=time; 
  } 
  else 
  { 
   p = first; 
   while(1) 
   { 
    if(p->at<=time && p->bt1!=0) 
     break; 
 
    p = delq(); 
    addq(p); 
    p = first; 
   } 
 
   if(p->bt1<=ts) 
   { 
    time+=p->bt1; 
    p->bt1=0; 
   } 
   else 
   { 
    time+=ts; 
    p->bt1-=ts; 
   } 
 
   p->ct = time; 
 
   s[k].start = prev; 
   strcpy(s[k].pname,p->pname); 
   s[k].end = time; 
 
   k++; 
   prev = time; 
    
   if(p->bt1==0) n1++; 
 
   p = delq(); 
   addq(p); 
  } 
 
  print_input(); 
 } 
} 
 
void print_gantt_chart() 
{ 
 int i,j,m; 
 
 s1[0] = s[0]; 
  
 for(i=1,j=0;i<k;i++) 
 { 
  if(strcmp(s[i].pname,s1[j].pname)==0) 
   s1[j].end = s[i].end; 
  else 
   s1[++j] = s[i]; 
 } 
 
 printf("%d",s1[0].start); 
 for(i=0;i<=j;i++) 
 { 
  m = (s1[i].end - s1[i].start); 
 
  for(k=0;k<m/2;k++) 
   printf("-"); 
 
  printf("%s",s1[i].pname); 
 
  for(k=0;k<(m+1)/2;k++) 
   printf("-"); 
 
  printf("%d",s1[i].end); 
 } 
} 
 
int main() 
{ 
 accept_info(); 
 sort(); 
 rr(); 
 print_output(); 
 print_gantt_chart(); 
 
 return 0; 
} 
 
Write a simulation program to implement demand paging using LRU (Using Counter) page 
replacement algorithm. Assume the memory of “n” frames. Show the contents of page after every 
page replacement in a frame and at end show the total number of page faults accordingly. Input the 
following Page Reference String : Page Reference String  : 12, 15, 12, 18, 6, 8, 11, 12, 19, 12, 6, 8, 
12, 15, 19, 8 
 
#include<stdio.h> 
#define MAX 20 
 
int frames[MAX],ref[MAX],mem[MAX][MAX],faults, 
 sp,m,n,time[MAX]; 
 
void accept() 
{ 
 int i; 
 
 printf("Enter no.of frames:"); 
 scanf("%d", &n); 
 
 printf("Enter no.of references:"); 
 scanf("%d", &m); 
 
 printf("Enter reference string:\n"); 
 for(i=0;i<m;i++) 
 { 
  printf("[%d]=",i); 
  scanf("%d",&ref[i]); 
 } 
} 
 
void disp() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
  printf("%3d",ref[i]); 
 
 printf("\n\n"); 
 
 for(i=0;i<n;i++) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(mem[i][j]) 
    printf("%3d",mem[i][j]); 
   else 
    printf("   "); 
  } 
  printf("\n"); 
 } 
 
 printf("Total Page Faults: %d\n",faults); 
} 
 
int search(int pno) 
{ 
 int i; 
 
 for(i=0;i<n;i++) 
 { 
  if(frames[i]==pno) 
   return i; 
 } 
 
 return -1; 
} 
 
int get_lru() 
{ 
 int i,min_i,min=9999; 
 
 for(i=0;i<n;i++) 
 { 
  if(time[i]<min) 
  { 
   min = time[i]; 
   min_i = i; 
  } 
 } 
 
 return min_i; 
} 
 
 
void lru() 
{ 
 int i,j,k; 
 
 for(i=0;i<m && sp<n;i++) 
 { 
  k=search(ref[i]); 
  if(k==-1) 
  { 
   frames[sp]=ref[i]; 
   time[sp]=i; 
   faults++; 
   sp++; 
 
   for(j=0;j<n;j++) 
    mem[j][i]=frames[j]; 
  } 
  else 
   time[k]=i; 
   
 } 
 
 for(;i<m;i++) 
 { 
  k = search(ref[i]); 
  if(k==-1) 
  { 
   sp = get_lru(); 
   frames[sp] = ref[i]; 
   time[sp] = i; 
   faults++; 
 
   for(j=0;j<n;j++) 
    mem[j][i] = frames[j]; 
  } 
  else 
   time[k]=i; 
 } 
} 
       
 
int main() 
{ 
 accept(); 
 lru(); 
 disp(); 
 
 return 0; 
} 
 
 
Write a program to implement a toy shell (Command Interpreter). It has its own prompt say “MyShell 
$”. Any normal shell command is executed from this shell (MyShell$) by starting a child process to 
execute the system program corresponding to the command. It should additionally interpret the 
following commands:  
o list f dirname : To print names of all the files in current directory  
o list n dirname : To print the number of all entries in the current directory. 
o list i dirname : To print names and inodes of the files in the current directory.  
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
#include <dirent.h> 
 
void make_toks(char *s, char *tok[]) 
{ 
 int i=0; 
 char *p; 
 
 p = strtok(s," "); 
 while(p!=NULL) 
 { 
  tok[i++]=p; 
  p=strtok(NULL," "); 
 } 
 
 tok[i]=NULL; 
} 
 
void list(char *dn, char op) 
{ 
 DIR *dp; 
 struct dirent *entry; 
 int dc=0,fc=0; 
 
 dp = opendir(dn); 
 if(dp==NULL) 
 { 
  printf("Dir %s not found.\n",dn); 
  return; 
 } 
 
 switch(op) 
 { 
 case 'f': 
  while(entry=readdir(dp)) 
  { 
   if(entry->d_type==DT_REG) 
    printf("%s\n",entry->d_name); 
  } 
  break; 
 case 'n': 
  while(entry=readdir(dp)) 
  { 
   if(entry->d_type==DT_DIR) dc++; 
   if(entry->d_type==DT_REG) fc++; 
  } 
  
  printf("%d Dir(s)\t%d File(s)\n",dc,fc); 
  break; 
 case 'i': 
  while(entry=readdir(dp)) 
  { 
   if(entry->d_type==DT_REG) 
    printf("%s\t%d\n",entry->d_name,entry->d_fileno); 
  } 
 } 
 
 closedir(dp); 
} 
 
int main() 
{ 
 char buff[80],*args[10]; 
 int pid; 
 
 while(1) 
 { 
  printf("myshell$"); 
  fflush(stdin); 
  fgets(buff,80,stdin); 
  buff[strlen(buff)-1]='\0'; 
  make_toks(buff,args); 
  if(strcmp(args[0],"list")==0) 
   list(args[2],args[1][0]); 
  else 
  { 
   pid = fork(); 
   if(pid>0) 
    wait(); 
   else 
   { 
    if(execvp(args[0],args)==-1) 
     printf("Bad command.\n"); 
   } 
  } 
 } 
 
 return 0; 
} 
 
1. Write a simulation program to implement sequential (Contiguous) Allocation method for file. 
Assume disk having “n” number of blocks ranging from 0 to n-1. Randomly mark some of the 
blocks as allocated and accordingly maintain the list of free blocks. Perform the following 
operation using following menu. 
o Show Bit Vector 
o Create New File 
o Show Directory 
o Delete File 
o Exit 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#define MAX 200 
 
typedef struct dir 
{ 
 char fname[20]; 
 int start; 
 struct dir *next; 
}NODE; 
 
NODE *first,*last; 
 
int n,fb,bit[MAX]; 
 
void init() 
{ 
 int i; 
 
 printf("Enter total no.of disk blocks:"); 
 scanf("%d",&n); 
 
 fb = n; 
 
 for(i=0;i<10;i++) 
 { 
  int k = rand()%n; 
  if(bit[k]!=-2) 
  { 
   bit[k]=-2; 
   fb--; 
  } 
 } 
} 
 
void show_bitvector() 
{ 
 int i; 
 for(i=0;i<n;i++) 
  printf("%d ",bit[i]); 
 printf("\n"); 
} 
 
void show_dir() 
{ 
 NODE *p; 
 int i; 
 
 printf("File\tChain\n"); 
  
 p = first; 
 while(p!=NULL) 
 { 
  printf("%s\t",p->fname); 
  i = p->start; 
  while(i!=-1) 
  { 
   printf("%d->",i); 
   i=bit[i]; 
  } 
  printf("NULL\n"); 
  
  p=p->next; 
 } 
} 
 
void create() 
{ 
 NODE *p; 
 char fname[20]; 
 int i,j,nob; 
 
 printf("Enter file name:"); 
 scanf("%s",fname); 
 
 printf("Enter no.of blocks:"); 
 scanf("%d",&nob); 
 
 if(nob>fb) 
 { 
  printf("Failed to create file %s\n",fname); 
  return; 
 } 
 
 for(i=0;i<n;i++) 
 { 
  if(bit[i]==0) break; 
 } 
 
 p = (NODE*)malloc(sizeof(NODE)); 
 strcpy(p->fname,fname); 
 p->start=i; 
 p->next=NULL; 
 
 if(first==NULL) 
  first=p; 
 else 
  last->next=p; 
 
 last=p; 
 
 fb-=nob; 
 
 j=i+1; 
 nob--; 
 
 while(nob>0) 
 { 
  if(bit[j]==0) 
  { 
   bit[i]=j; 
   i=j; 
   nob--; 
  } 
  j++; 
 } 
 
 bit[i]=-1; 
 printf("File %s created successully.\n",fname); 
} 
 
void delete() 
{ 
 char fname[20]; 
 NODE *p,*q; 
 int nob=0,i,j; 
 
 printf("Enter file name to be deleted:"); 
 scanf("%s",fname); 
 
 p = q = first; 
 while(p!=NULL) 
 { 
  if(strcmp(p->fname,fname)==0) 
   break; 
 
  q=p; 
  p=p->next; 
 } 
 
 if(p==NULL) 
 { 
  printf("File %s not found.\n",fname); 
  return; 
 } 
 
 i = p->start; 
 while(i!=-1) 
 { 
  nob++; 
  j = i; 
  i = bit[i]; 
  bit[j] = 0; 
 } 
 
 fb+=nob; 
  
 if(p==first) 
  first=first->next; 
 else if(p==last) 
 { 
  last=q; 
  last->next=NULL; 
 } 
 else 
  q->next = p->next; 
 
 free(p); 
  
 printf("File %s deleted successfully.\n",fname); 
} 
 
int main() 
{ 
 int ch; 
 
 init(); 
 
 while(1) 
 { 
  printf("1.Show bit vector\n"); 
  printf("2.Create new file\n"); 
  printf("3.Show directory\n"); 
  printf("4.Delete file\n"); 
  printf("5.Exit\n"); 
  printf("Enter your choice (1-5):"); 
  scanf("%d",&ch); 
 
  switch(ch) 
  { 
  case 1: 
   show_bitvector(); 
   break; 
  case 2: 
   create(); 
   break; 
  case 3: 
   show_dir(); 
   break; 
  case 4: 
   delete(); 
   break; 
  case 5: 
   exit(0); 
  } 
 } 
 
1. Write a simulation program to implement demand paging using MFU page replacement 
algorithm. Assume the memory of “n” frame. Show the contents of page after every page 
replacement in a frame and at end show the total number of page faults accordingly. Input 
the following Page Reference String: Page Replacement String: 8, 5, 7, 8, 5, 7, 2, 3, 7, 3, 5, 
9, 4, 6, 2.  
#include<stdio.h> 
#define MAX 20 
 
int frames[MAX],ref[MAX],mem[MAX][MAX],faults, 
 sp,m,n,count[MAX]; 
 
void accept() 
{ 
 int i; 
 
 printf("Enter no.of frames:"); 
 scanf("%d", &n); 
 
 printf("Enter no.of references:"); 
 scanf("%d", &m); 
 
 printf("Enter reference string:\n"); 
 for(i=0;i<m;i++) 
 { 
  printf("[%d]=",i); 
  scanf("%d",&ref[i]); 
 } 
} 
 
void disp() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
  printf("%3d",ref[i]); 
 
 printf("\n\n"); 
 
 for(i=0;i<n;i++) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(mem[i][j]) 
    printf("%3d",mem[i][j]); 
   else 
    printf("   "); 
  } 
  printf("\n"); 
 } 
 
 printf("Total Page Faults: %d\n",faults); 
} 
 
int search(int pno) 
{ 
 int i; 
 
 for(i=0;i<n;i++) 
 { 
  if(frames[i]==pno) 
   return i; 
 } 
 
 return -1; 
} 
 
int get_mfu(int sp) 
{ 
 int i,max_i,max=-9999; 
 
 i=sp; 
 do 
 { 
  if(count[i]>max) 
  { 
   max = count[i]; 
   max_i = i; 
  } 
  i=(i+1)%n; 
 }while(i!=sp); 
 
 return max_i; 
} 
 
void mfu() 
{ 
 int i,j,k; 
 
 for(i=0;i<m && sp<n;i++) 
 { 
  k=search(ref[i]); 
  if(k==-1) 
  { 
   frames[sp]=ref[i]; 
   count[sp]++; 
   faults++; 
   sp++; 
 
   for(j=0;j<n;j++) 
    mem[j][i]=frames[j]; 
  } 
  else 
   count[k]++; 
   
 } 
 
 sp=0; 
 for(;i<m;i++) 
 { 
  k = search(ref[i]); 
  if(k==-1) 
  { 
   sp = get_mfu(sp); 
   frames[sp] = ref[i]; 
   count[sp]=1; 
   faults++; 
   sp = (sp+1)%n; 
 
   for(j=0;j<n;j++) 
    mem[j][i] = frames[j]; 
  } 
  else 
   count[k]++; 
 } 
} 
       
 
int main() 
{ 
 accept(); 
 mfu(); 
 disp(); 
 
 return 0; 
} 
 
 
Write the simulation program to implement demand paging using FIFO page replacement algorithm. 
Assume the memory of “n” frames. Show the contents of page after every page replacement in a 
frame and at end show the total number of page faults accordingly. Input the following Page 
Reference String: Page Reference String: 3,4,5,6,3,4,7,3,4,5,6,7,2,4,6. 
 
#include<stdio.h> 
#define MAX 20 
 
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,sp,m,n; 
 
void accept() 
{ 
 int i; 
 
 printf("Enter no.of frames:"); 
 scanf("%d", &n); 
 
 printf("Enter no.of references:"); 
 scanf("%d", &m); 
 
 printf("Enter reference string:\n"); 
 for(i=0;i<m;i++) 
 { 
  printf("[%d]=",i); 
  scanf("%d",&ref[i]); 
 } 
} 
 
void disp() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
  printf("%3d",ref[i]); 
 
 printf("\n\n"); 
 
 for(i=0;i<n;i++) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(mem[i][j]) 
    printf("%3d",mem[i][j]); 
   else 
    printf("   "); 
  } 
  printf("\n"); 
 } 
 
 printf("Total Page Faults: %d\n",faults); 
} 
 
int search(int pno) 
{ 
 int i; 
 
 for(i=0;i<n;i++) 
 { 
  if(frames[i]==pno) 
   return i; 
 } 
 
 return -1; 
} 
 
void fifo() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
 { 
  if(search(ref[i])==-1) 
  { 
   frames[sp] = ref[i]; 
   sp = (sp+1)%n; 
   faults++; 
   for(j=0;j<n;j++) 
    mem[j][i] = frames[j]; 
 
} 
} 
} 
int main() 
{ 
accept(); 
fifo(); 
disp(); 
return 0; 
} 
Consider the following snapshot of the system  
Calculate and display the contents of matrix Need. Using Safety and Resource-Request Algorithm 
perform the following operations:  
o Check whether the current system is in safe state or not.  
o If a request from process P1 arrives as (1, 0, 2), can it be granted immediately by 
keeping system in safe state. 
#include<stdio.h> 
#define MAX 10 
int m,n,total[MAX],avail[MAX],alloc[MAX][MAX], 
max[MAX][MAX],need[MAX][MAX],work[MAX],finish[MAX], 
seq[MAX],request[MAX]; 
void accept() 
{ 
int i,j; 
printf("Enter no.of process:"); 
scanf("%d",&n); 
printf("Enter no.of resource types:"); 
scanf("%d",&m); 
printf("Enter total no.of resources of each resource type:\n"); 
 
 for(i=0;i<m;i++) 
 { 
  printf("%c:",65+i); 
  scanf("%d",&total[i]); 
 } 
 
 printf("Enter no.of allocated resources of each resource type by each process:\n"); 
 
 for(i=0;i<n;i++) 
 { 
  printf("P%d:\n",i); 
  for(j=0;j<m;j++) 
  { 
   printf("%c:",65+j); 
   scanf("%d",&alloc[i][j]); 
  } 
 } 
 
 printf("Enter no.of maximum resources of each resource type by each process:\n");    
  
 for(i=0;i<n;i++) 
 { 
  printf("P%d:\n",i); 
  for(j=0;j<m;j++) 
  { 
   printf("%c:",65+j); 
   scanf("%d",&max[i][j]); 
  } 
 } 
} 
 
void calc_avail() 
{ 
 int i,j,s; 
 
 for(j=0;j<m;j++) 
 { 
  s=0; 
  for(i=0;i<n;i++) 
   s+=alloc[i][j]; 
 
  avail[j] = total[j] - s; 
 } 
} 
 
void calc_need() 
{ 
 int i,j; 
 
 for(i=0;i<n;i++) 
  for(j=0;j<m;j++) 
   need[i][j]=max[i][j]-alloc[i][j]; 
} 
 
void print() 
{ 
 int i,j; 
  
 printf("\tAllocation\tMax\tNeed\n\t"); 
 
 for(i=0;i<3;i++) 
 { 
  for(j=0;j<m;j++) 
   printf("%3c",65+j); 
  printf("\t"); 
 } 
 
 printf("\n"); 
 for(i=0;i<n;i++) 
 { 
  printf("P%d\t",i); 
  for(j=0;j<m;j++) 
   printf("%3d",alloc[i][j]); 
  printf("\t"); 
  for(j=0;j<m;j++) 
   printf("%3d",max[i][j]); 
  printf("\t"); 
  for(j=0;j<m;j++) 
   printf("%3d",need[i][j]); 
  printf("\n"); 
 } 
 
 printf("Available\n"); 
 for(j=0;j<m;j++) 
  printf("%3c",65+j); 
 printf("\n"); 
 for(j=0;j<m;j++) 
  printf("%3d",avail[j]); 
 
 printf("\n"); 
} 
 
int check(int s) 
{ 
 int i,j; 
 
 i = s; 
 do 
 { 
  if(!finish[i]) 
  { 
   for(j=0;j<m;j++) 
   { 
    if(need[i][j]>work[j]) 
     break; 
   } 
    
   if(j==m) return i; 
  } 
 
  i=(i+1)%n; 
 }while(i!=s); 
 
 return -1; 
} 
 
void banker() 
{ 
 int i,j,k=0; 
 
 for(i=0;i<n;i++) 
  finish[i]=0; 
 
 for(j=0;j<m;j++) 
  work[j] = avail[j]; 
 
 i=0; 
 while((i=check(i))!=-1) 
 { 
  printf("Process P%d resource granted.\n",i); 
  finish[i] = 1; 
   
  for(j=0;j<m;j++) 
   work[j] += alloc[i][j]; 
  
  printf("finish("); 
  for(j=0;j<n;j++) 
   printf("%d,",finish[j]); 
  printf("\b)\nwork("); 
  for(j=0;j<m;j++) 
   printf("%d,",work[j]); 
  printf("\b)\n"); 
 
  seq[k++]=i; 
  
  i=(i+1)%n; 
 } 
 
 if(k==n) 
 { 
  printf("System is in safe state.\n"); 
  printf("Safe sequence:"); 
  for(j=0;j<n;j++) 
   printf("P%d ",seq[j]); 
 } 
 else 
 { 
  printf("System is not in safe state."); 
 } 
 printf("\n"); 
} 
 
int main() 
{ 
 int i,j,pno; 
 
 accept(); 
 calc_avail(); 
 calc_need(); 
 print(); 
 banker(); 
 
 printf("Enter process no:"); 
 scanf("%d",&pno); 
 
 printf("Enter resource request of process P%d\n",pno); 
 
 for(j=0;j<m;j++) 
 { 
  printf("%c:",65+j); 
  scanf("%d",&request[j]); 
 } 
 
 for(j=0;j<m;j++) 
 { 
  if(request[j]>need[pno][j]) 
   break; 
 } 
 
 if(j==m) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(request[j]>avail[j]) 
    break; 
  } 
 
  if(j==m) 
  { 
   for(j=0;j<m;j++) 
   { 
    avail[j]-=request[j]; 
    alloc[pno][j]+=request[j]; 
    need[pno][j]-=request[j]; 
    print(); 
    banker(); 
   } 
  } 
  else 
   printf("Process P%d must wait.\n",pno); 
 } 
 else 
  printf("Process P%d has exceeded its maximum claim\n",pno); 
 
 return 0; 
} 
 
Write a simulation program to implement demand paging using FIFO page replacement algorithm. 
Assume the memory of “n” frames. Show the contents of page after every page replacement in a 
frame and at end show the total number of page faults accordingly. Input the following Page 
Reference String. Page Reference String : 3,4,5,4,3,47,2,4,5,6,7,2,4,6 
 
#include<stdio.h> 
#define MAX 20 
 
int frames[MAX],ref[MAX],mem[MAX][MAX],faults,sp,m,n; 
 
void accept() 
{ 
 int i; 
 
 printf("Enter no.of frames:"); 
 scanf("%d", &n); 
 
 printf("Enter no.of references:"); 
 scanf("%d", &m); 
 
 printf("Enter reference string:\n"); 
 for(i=0;i<m;i++) 
 { 
  printf("[%d]=",i); 
  scanf("%d",&ref[i]); 
 } 
} 
 
void disp() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
  printf("%3d",ref[i]); 
 
 printf("\n\n"); 
 
 for(i=0;i<n;i++) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(mem[i][j]) 
    printf("%3d",mem[i][j]); 
   else 
    printf("   "); 
  } 
  printf("\n"); 
 } 
 
 printf("Total Page Faults: %d\n",faults); 
} 
 
int search(int pno) 
{ 
 int i; 
 
 for(i=0;i<n;i++) 
 { 
  if(frames[i]==pno) 
   return i; 
 } 
 
 return -1; 
} 
 
void fifo() 
{ 
 int i,j; 
 
 for(i=0;i<m;i++) 
 { 
  if(search(ref[i])==-1) 
  { 
   frames[sp] = ref[i]; 
   sp = (sp+1)%n; 
   faults++; 
   for(j=0;j<n;j++) 
    mem[j][i] = frames[j]; 
 
  } 
 } 
} 
 
int main() 
{ 
 accept(); 
 fifo(); 
 disp(); 
 
 return 0; 
} 
 
Write a simulation program to implement a Pre-emptive Shortest Job First (SJF) – CPU scheduling 
algorithm. Accept the number of Processes as input. Also accept arrival time and CPU burst time for 
each process as input. The output should give the Gantt chart, turnaround time and waiting time for 
each process. Also display the average turnaround time and average waiting time. 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
 
typedef struct process_info 
{ 
 char pname[20]; 
 int at,bt,ct,bt1; 
 struct process_info *next; 
}NODE; 
 
int n; 
NODE *first,*last; 
 
void accept_info() 
{ 
 NODE *p; 
 int i; 
 
 printf("Enter no.of process:"); 
 scanf("%d",&n); 
 
 for(i=0;i<n;i++) 
 { 
  p = (NODE*)malloc(sizeof(NODE)); 
 
  printf("Enter process name:"); 
  scanf("%s",p->pname); 
 
  printf("Enter arrival time:"); 
  scanf("%d",&p->at); 
 
  printf("Enter first CPU burst time:"); 
  scanf("%d",&p->bt); 
 
  p->bt1 = p->bt; 
   
  p->next = NULL; 
 
  if(first==NULL) 
   first=p; 
  else 
   last->next=p; 
 
  last = p; 
 } 
} 
 
void print_output() 
{ 
 NODE *p; 
 float avg_tat=0,avg_wt=0; 
 
 printf("pname\tat\tbt\tct\ttat\twt\n"); 
 
 p = first; 
 while(p!=NULL) 
 { 
  int tat = p->ct-p->at; 
  int wt = tat-p->bt; 
   
  avg_tat+=tat; 
  avg_wt+=wt; 
 
  printf("%s\t%d\t%d\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt,p->ct,tat,wt); 
   
  p=p->next; 
 } 
 
 printf("Avg TAT=%f\tAvg WT=%f\n", 
   avg_tat/n,avg_wt/n); 
} 
 
void print_input() 
{ 
 NODE *p; 
 
 p = first; 
  
 printf("pname\tat\tbt\n"); 
 while(p!=NULL) 
 { 
  printf("%s\t%d\t%d\n", 
   p->pname,p->at,p->bt1); 
  p = p->next; 
 } 
} 
 
void sort() 
{ 
 NODE *p,*q; 
 int t; 
 char name[20]; 
 
 p = first; 
 while(p->next!=NULL) 
 { 
  q=p->next; 
  while(q!=NULL) 
  { 
   if(p->at > q->at) 
   { 
    strcpy(name,p->pname); 
    strcpy(p->pname,q->pname); 
    strcpy(q->pname,name); 
 
    t = p->at; 
    p->at = q->at; 
    q->at = t; 
     
    t = p->bt; 
    p->bt = q->bt; 
    q->bt = t; 
 
    t = p->ct; 
    p->ct = q->ct; 
    q->ct = t; 
 
    t = p->bt1; 
    p->bt1 = q->bt1; 
    q->bt1 = t; 
   } 
 
   q=q->next; 
  } 
  
  p=p->next; 
 } 
} 
 
int time; 
 
NODE * get_sjf() 
{ 
 NODE *p,*min_p=NULL; 
 int min=9999; 
 
 p = first; 
 while(p!=NULL) 
 { 
  if(p->at<=time && p->bt1!=0 && 
   p->bt1<min) 
  { 
   min = p->bt1; 
   min_p = p; 
  } 
  p=p->next; 
 } 
 
 return min_p; 
} 
 
struct gantt_chart 
{ 
 int start; 
 char pname[30]; 
 int end; 
}s[100],s1[100]; 
 
int k; 
 
void sjfp() 
{ 
 int prev=0,n1=0; 
 NODE *p; 
 
 while(n1!=n) 
 { 
  p = get_sjf(); 
 
  if(p==NULL) 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname,"*"); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
  } 
  else 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname, p->pname); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
 
   p->ct = time; 
   p->bt1--; 
 
   if(p->bt1==0) 
    n1++; 
  } 
 
  print_input();  
  sort(); 
 } 
} 
 
void print_gantt_chart() 
{ 
 int i,j,m; 
 
 s1[0] = s[0]; 
  
 for(i=1,j=0;i<k;i++) 
 { 
  if(strcmp(s[i].pname,s1[j].pname)==0) 
   s1[j].end = s[i].end; 
  else 
   s1[++j] = s[i]; 
 } 
 
 printf("%d",s1[0].start); 
 for(i=0;i<=j;i++) 
 { 
  m = (s1[i].end - s1[i].start); 
 
  for(k=0;k<m/2;k++) 
   printf("-"); 
 
  printf("%s",s1[i].pname); 
 
  for(k=0;k<(m+1)/2;k++) 
   printf("-"); 
 
  printf("%d",s1[i].end); 
 } 
} 
 
int main() 
{ 
 accept_info(); 
 sort(); 
 sjfp(); 
 print_output(); 
 print_gantt_chart(); 
 
 return 0; 
} 
 
Write a simulation program to implement a linked allocation method for file. Assume disk having “n” 
number of blocks ranging from 0 to n-1. Randomly mark some blocks as allocated and accordingly 
maintain the list of free blocks. Perform the following operation using the following menu: 
o Show Bit Vector 
o Create New File 
o Show Directory 
o Delete File 
o Exit 
 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
#define MAX 200 
 
typedef struct dir 
{ 
 char fname[20]; 
 int start; 
 struct dir *next; 
}NODE; 
 
NODE *first,*last; 
 
int n,fb,bit[MAX]; 
 
void init() 
{ 
 int i; 
 
 printf("Enter total no.of disk blocks:"); 
 scanf("%d",&n); 
 
 fb = n; 
 
 for(i=0;i<10;i++) 
 { 
  int k = rand()%n; 
  if(bit[k]!=-2) 
  { 
   bit[k]=-2; 
   fb--; 
  } 
 } 
} 
 
void show_bitvector() 
{ 
 int i; 
 for(i=0;i<n;i++) 
  printf("%d ",bit[i]); 
 printf("\n"); 
} 
 
void show_dir() 
{ 
 NODE *p; 
 int i; 
 
 printf("File\tChain\n"); 
  
 p = first; 
 while(p!=NULL) 
 { 
  printf("%s\t",p->fname); 
  i = p->start; 
  while(i!=-1) 
  { 
   printf("%d->",i); 
   i=bit[i]; 
  } 
  printf("NULL\n"); 
  
  p=p->next; 
 } 
} 
 
void create() 
{ 
 NODE *p; 
 char fname[20]; 
 int i,j,nob; 
 
 printf("Enter file name:"); 
 scanf("%s",fname); 
 
 printf("Enter no.of blocks:"); 
 scanf("%d",&nob); 
 
 if(nob>fb) 
 { 
  printf("Failed to create file %s\n",fname); 
  return; 
 } 
 
 for(i=0;i<n;i++) 
 { 
  if(bit[i]==0) break; 
 } 
 
 p = (NODE*)malloc(sizeof(NODE)); 
 strcpy(p->fname,fname); 
 p->start=i; 
 p->next=NULL; 
 
 if(first==NULL) 
  first=p; 
 else 
  last->next=p; 
 
 last=p; 
 
 fb-=nob; 
 
 j=i+1; 
 nob--; 
 
 while(nob>0) 
 { 
  if(bit[j]==0) 
  { 
   bit[i]=j; 
   i=j; 
   nob--; 
  } 
  j++; 
 } 
 
 bit[i]=-1; 
 printf("File %s created successully.\n",fname); 
} 
 
void delete() 
{ 
 char fname[20]; 
 NODE *p,*q; 
 int nob=0,i,j; 
 
 printf("Enter file name to be deleted:"); 
 scanf("%s",fname); 
 
 p = q = first; 
 while(p!=NULL) 
 { 
  if(strcmp(p->fname,fname)==0) 
   break; 
 
  q=p; 
  p=p->next; 
 } 
 
 if(p==NULL) 
 { 
  printf("File %s not found.\n",fname); 
  return; 
 } 
 
 i = p->start; 
 while(i!=-1) 
 { 
  nob++; 
  j = i; 
  i = bit[i]; 
  bit[j] = 0; 
 } 
 
 fb+=nob; 
  
 if(p==first) 
  first=first->next; 
 else if(p==last) 
 { 
  last=q; 
  last->next=NULL; 
 } 
 else 
  q->next = p->next; 
 
 free(p); 
  
 printf("File %s deleted successfully.\n",fname); 
} 
 
int main() 
{ 
 int ch; 
 
 init(); 
 
 while(1) 
 { 
  printf("1.Show bit vector\n"); 
  printf("2.Create new file\n"); 
  printf("3.Show directory\n"); 
  printf("4.Delete file\n"); 
  printf("5.Exit\n"); 
  printf("Enter your choice (1-5):"); 
  scanf("%d",&ch); 
 
  switch(ch) 
  { 
  case 1: 
   show_bitvector(); 
   break; 
  case 2: 
   create(); 
   break; 
  case 3: 
   show_dir(); 
   break; 
  case 4: 
   delete(); 
   break; 
  case 5: 
   exit(0); 
  } 
 } 
 
 return 0; 
} 
 
 
Write a simulation program to implement Pre-emptive Priority CPU scheduling algorithm. Accept the 
number of processes, arrival time, CPU burst time and priority for each process as input. Priorities 
should in High to Low order (1 is High). The output should give the Gantt chart, turnaround time and 
waiting time for each process. Also display the average turnaround time and average waiting time. 
 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
 
typedef struct process_info 
{ 
 char pname[20]; 
 int at,bt,ct,bt1,p; 
 struct process_info *next; 
}NODE; 
 
int n; 
NODE *first,*last; 
 
void accept_info() 
{ 
 NODE *p; 
 int i; 
 
 printf("Enter no.of process:"); 
 scanf("%d",&n); 
 
 for(i=0;i<n;i++) 
 { 
  p = (NODE*)malloc(sizeof(NODE)); 
 
  printf("Enter process name:"); 
  scanf("%s",p->pname); 
 
  printf("Enter arrival time:"); 
  scanf("%d",&p->at); 
 
  printf("Enter first CPU burst time:"); 
  scanf("%d",&p->bt); 
 
  printf("Enter priority:"); 
  scanf("%d",&p->p); 
 
  p->bt1 = p->bt; 
   
  p->next = NULL; 
 
  if(first==NULL) 
   first=p; 
  else 
   last->next=p; 
 
  last = p; 
 } 
} 
 
void print_output() 
{ 
 NODE *p; 
 float avg_tat=0,avg_wt=0; 
 
 printf("pname\tat\tbt\tp\ttct\ttat\twt\n"); 
 
 p = first; 
 while(p!=NULL) 
 { 
  int tat = p->ct-p->at; 
  int wt = tat-p->bt; 
   
  avg_tat+=tat; 
  avg_wt+=wt; 
 
  printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt,p->p,p->ct,tat,wt); 
   
  p=p->next; 
 } 
 
 printf("Avg TAT=%f\tAvg WT=%f\n", 
   avg_tat/n,avg_wt/n); 
} 
 
void print_input() 
{ 
 NODE *p; 
 
 p = first; 
  
 printf("pname\tat\tbt\tp\n"); 
 while(p!=NULL) 
 { 
  printf("%s\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt1,p->p); 
  p = p->next; 
 } 
} 
 
void sort() 
{ 
 NODE *p,*q; 
 int t; 
 char name[20]; 
 
 p = first; 
 while(p->next!=NULL) 
 { 
  q=p->next; 
  while(q!=NULL) 
  { 
   if(p->at > q->at) 
   { 
    strcpy(name,p->pname); 
    strcpy(p->pname,q->pname); 
    strcpy(q->pname,name); 
 
    t = p->at; 
    p->at = q->at; 
    q->at = t; 
     
    t = p->bt; 
    p->bt = q->bt; 
    q->bt = t; 
 
    t = p->ct; 
    p->ct = q->ct; 
    q->ct = t; 
 
    t = p->bt1; 
    p->bt1 = q->bt1; 
    q->bt1 = t; 
    
    t = p->p; 
    p->p = q->p; 
    q->p = t; 
 
   } 
 
   q=q->next; 
  } 
  
  p=p->next; 
 } 
} 
 
int time; 
 
NODE * get_p() 
{ 
 NODE *p,*min_p=NULL; 
 int min=9999; 
 
 p = first; 
 while(p!=NULL) 
 { 
  if(p->at<=time && p->bt1!=0 && 
   p->p<min) 
  { 
   min = p->p; 
   min_p = p; 
  } 
  p=p->next; 
 } 
 
 return min_p; 
} 
 
struct gantt_chart 
{ 
 int start; 
 char pname[30]; 
 int end; 
}s[100],s1[100]; 
 
int k; 
 
void pnp() 
{ 
 int prev=0,n1=0; 
 NODE *p; 
 
 while(n1!=n) 
 { 
  p = get_p(); 
 
  if(p==NULL) 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname,"*"); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
  } 
  else 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname, p->pname); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
 
   p->ct = time; 
   p->bt1--; 
 
   if(p->bt1==0) n1++; 
  } 
 
  print_input();  
  sort(); 
 } 
} 
 
void print_gantt_chart() 
{ 
 int i,j,m; 
 
 s1[0] = s[0]; 
  
 for(i=1,j=0;i<k;i++) 
 { 
  if(strcmp(s[i].pname,s1[j].pname)==0) 
   s1[j].end = s[i].end; 
  else 
   s1[++j] = s[i]; 
 } 
 
 printf("%d",s1[0].start); 
 for(i=0;i<=j;i++) 
 { 
  m = (s1[i].end - s1[i].start); 
 
  for(k=0;k<m/2;k++) 
   printf("-"); 
 
  printf("%s",s1[i].pname); 
 
  for(k=0;k<(m+1)/2;k++) 
   printf("-"); 
 
  printf("%d",s1[i].end); 
 } 
} 
 
int main() 
{ 
 accept_info(); 
 sort(); 
 pnp(); 
 print_output(); 
 print_gantt_chart(); 
 
 return 0; 
} 
 
Write a program to implement a toy shell (Command Interpreter). It has its own prompt say “MyShell 
$”. Any normal shell command is executed from this shell (MyShell$) by starting a child process to 
execute the system program corresponding to the command. It should additionally interpret the 
following commands:   
o search f file name :- To search first occurrence of the pattern in the file  
o search a file name :- To search all the occurrence of the pattern in the file  
o search c file name :- To count the number of occurrence of the pattern in the file.  
 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
 
void make_toks(char *s, char *tok[]) 
{ 
 int i=0; 
 char *p; 
 
 p = strtok(s," "); 
 while(p!=NULL) 
 { 
  tok[i++]=p; 
  p=strtok(NULL," "); 
 } 
 
 tok[i]=NULL; 
} 
 
void search(char *fn, char op, char *pattern) 
{ 
 int fh,count=0,i=0,j=0; 
 char buff[255],c,*p; 
 
 fh = open(fn,O_RDONLY); 
 if(fh==-1) 
 { 
  printf("File %s Not Found\n",fn); 
  return; 
 } 
 
 switch(op) 
 { 
 case 'f': 
  while(read(fh,&c,1)) 
  { 
   buff[j++]=c; 
   if(c=='\n') 
   { 
    buff[j]='\0'; 
    j=0; 
    i++; 
    if(strstr(buff,pattern)) 
    { 
     printf("%d: %s",i,buff); 
     break; 
    } 
   } 
  } 
  break; 
 case 'c': 
  while(read(fh,&c,1)) 
  { 
   buff[j++]=c; 
   if(c=='\n') 
   { 
    buff[j]='\0'; 
    j=0; 
    p = buff; 
    while(p=strstr(p,pattern)) 
    { 
     count++; 
     p++; 
    } 
   } 
  } 
  printf("Total No.of Occurrences = %d\n",count); 
  break; 
 case 'a': 
  while(read(fh,&c,1)) 
  { 
   buff[j++]=c; 
   if(c=='\n') 
   { 
    buff[j]='\0'; 
    j = 0; 
    i++; 
    if(strstr(buff,pattern)) 
     printf("%d: %s",i,buff); 
   } 
  } 
 }//switch 
 close(fh); 
}//search 
 
int main() 
{ 
 char buff[80],*args[10]; 
 int pid; 
 
 while(1) 
 { 
  printf("myshell$"); 
  fflush(stdin); 
  fgets(buff,80,stdin); 
  buff[strlen(buff)-1]='\0'; 
  make_toks(buff,args); 
  if(strcmp(args[0],"search")==0) 
   search(args[3],args[1][0],args[2]); 
  else 
  { 
   pid = fork(); 
   if(pid>0) 
    wait(); 
   else 
   { 
    if(execvp(args[0],args)==-1) 
     printf("Bad command.\n"); 
   } 
  } 
 } 
 
 return 0; 
} 
 
 
Write a program to implement a toy shell (Command Interpreter). It has its own prompt say “MyShell 
$”. Any normal shell command is executed from this shell (MyShell$) by starting a child process to 
execute the system program corresponding to the command. It should additionally interpret the 
following commands:  
o typeline  +n  filename :- To print first n lines in the file. 
o typeline   -n   filename :- To print last n lines in the file.  
o typeline   a filename  :- To print all the lines in the file. 
 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
 
void make_toks(char *s, char *tok[]) 
{ 
 int i=0; 
 char *p; 
 
 p = strtok(s," "); 
 while(p!=NULL) 
 { 
  tok[i++]=p; 
  p=strtok(NULL," "); 
 } 
 
 tok[i]=NULL; 
} 
 
void typeline(char *fn, char *op) 
{ 
 int fh,i,j,n; 
 char c; 
 
 fh = open(fn,O_RDONLY); 
 if(fh==-1) 
 { 
  printf("File %s not found.\n",fn); 
  return; 
 } 
 
 if(strcmp(op,"a")==0) 
 { 
  while(read(fh,&c,1)>0) 
   printf("%c",c); 
  close(fh); 
  return; 
 } 
 
 n = atoi(op); 
 if(n>0) 
 { 
  i=0; 
  while(read(fh,&c,1)>0) 
  { 
   printf("%c",c); 
   if(c=='\n') i++; 
   if(i==n) break; 
  } 
 } 
 
 if(n<0) 
 { 
  i=0; 
  while(read(fh,&c,1)>0) 
  { 
   if(c=='\n') i++; 
  } 
  lseek(fh,0,SEEK_SET); 
  j=0; 
  while(read(fh,&c,1)>0) 
  { 
   if(c=='\n') j++; 
   if(j==i+n) break; 
  } 
  while(read(fh,&c,1)>0) 
  { 
   printf("%c",c); 
  } 
 } 
 
 close(fh); 
} 
 
int main() 
{ 
 char buff[80],*args[10]; 
 int pid; 
 
 while(1) 
 { 
  printf("myshell$"); 
  fflush(stdin); 
  fgets(buff,80,stdin); 
  buff[strlen(buff)-1]='\0'; 
  make_toks(buff,args); 
  if(strcmp(args[0],"typeline")==0) 
   typeline(args[2],args[1]); 
  else 
  { 
   pid = fork(); 
   if(pid>0) 
    wait(); 
   else 
   { 
    if(execvp(args[0],args)==-1) 
     printf("Bad command.\n"); 
   } 
  } 
 } 
 
 return 0; 
} 
 
Write a simulation program to implement FCFS CPU-scheduling algorithm. Accept the number of 
Processes as input. Also accept arrival time and CPU burst time for each process as input. The 
output should give the Gantt chart, turnaround time and waiting time for each process. Also display 
the average turnaround time and average waiting time.  
 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
 
typedef struct process_info 
{ 
 char pname[20]; 
 int at,bt,ct,bt1; 
 struct process_info *next; 
}NODE; 
 
int n; 
NODE *first,*last; 
 
void accept_info() 
{ 
 NODE *p; 
 int i; 
 
 printf("Enter no.of process:"); 
 scanf("%d",&n); 
 
 for(i=0;i<n;i++) 
 { 
  p = (NODE*)malloc(sizeof(NODE)); 
 
  printf("Enter process name:"); 
  scanf("%s",p->pname); 
 
  printf("Enter arrival time:"); 
  scanf("%d",&p->at); 
 
  printf("Enter first CPU burst time:"); 
  scanf("%d",&p->bt); 
 
  p->bt1 = p->bt; 
   
  p->next = NULL; 
 
  if(first==NULL) 
   first=p; 
  else 
   last->next=p; 
 
  last = p; 
 } 
} 
 
void print_output() 
{ 
 NODE *p; 
 float avg_tat=0,avg_wt=0; 
 
 printf("pname\tat\tbt\tct\ttat\twt\n"); 
 
 p = first; 
 while(p!=NULL) 
 { 
  int tat = p->ct-p->at; 
  int wt = tat-p->bt; 
   
  avg_tat+=tat; 
  avg_wt+=wt; 
 
  printf("%s\t%d\t%d\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt,p->ct,tat,wt); 
   
  p=p->next; 
 } 
 
 printf("Avg TAT=%f\tAvg WT=%f\n", 
   avg_tat/n,avg_wt/n); 
} 
 
void print_input() 
{ 
 NODE *p; 
 
 p = first; 
  
 printf("pname\tat\tbt\n"); 
 while(p!=NULL) 
 { 
  printf("%s\t%d\t%d\n", 
   p->pname,p->at,p->bt1); 
  p = p->next; 
 } 
} 
 
void sort() 
{ 
 NODE *p,*q; 
 int t; 
 char name[20]; 
 
 p = first; 
 while(p->next!=NULL) 
 { 
  q=p->next; 
  while(q!=NULL) 
  { 
   if(p->at > q->at) 
   { 
    strcpy(name,p->pname); 
    strcpy(p->pname,q->pname); 
    strcpy(q->pname,name); 
 
    t = p->at; 
    p->at = q->at; 
    q->at = t; 
     
    t = p->bt; 
    p->bt = q->bt; 
    q->bt = t; 
 
    t = p->ct; 
    p->ct = q->ct; 
    q->ct = t; 
 
    t = p->bt1; 
    p->bt1 = q->bt1; 
    q->bt1 = t; 
   } 
 
   q=q->next; 
  } 
  
  p=p->next; 
 } 
} 
 
int time; 
 
NODE * get_fcfs() 
{ 
 NODE *p; 
 
 p = first; 
 while(p!=NULL) 
 { 
  if(p->at<=time && p->bt1!=0) 
   return p; 
 
  p=p->next; 
 } 
 
 return NULL; 
} 
 
struct gantt_chart 
{ 
 int start; 
 char pname[30]; 
 int end; 
}s[100],s1[100]; 
 
int k; 
 
void fcfs() 
{ 
 int prev=0,n1=0; 
 NODE *p; 
 
 while(n1!=n) 
 { 
  p = get_fcfs(); 
 
  if(p==NULL) 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname,"*"); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
  } 
  else 
  { 
   time+=p->bt1; 
   s[k].start = prev; 
   strcpy(s[k].pname, p->pname); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
 
   p->ct = time; 
   p->bt1 = 0; 
 
   n1++; 
  } 
 
  print_input();  
  sort(); 
 } 
} 
 
void print_gantt_chart() 
{ 
 int i,j,m; 
 
 s1[0] = s[0]; 
  
 for(i=1,j=0;i<k;i++) 
 { 
  if(strcmp(s[i].pname,s1[j].pname)==0) 
   s1[j].end = s[i].end; 
  else 
   s1[++j] = s[i]; 
 } 
 
 printf("%d",s1[0].start); 
 for(i=0;i<=j;i++) 
 { 
  m = (s1[i].end - s1[i].start); 
 
  for(k=0;k<m/2;k++) 
   printf("-"); 
 
  printf("%s",s1[i].pname); 
 
  for(k=0;k<(m+1)/2;k++) 
   printf("-"); 
 
  printf("%d",s1[i].end); 
 } 
} 
 
int main() 
{ 
 accept_info(); 
 sort(); 
 fcfs(); 
 print_output(); 
 print_gantt_chart(); 
 
 return 0; 
} 
Write a program to implement a toy shell (Command Interpreter). It has its own prompt say “MyShell 
$”. Any normal shell command is executed from this shell (MyShell$) by starting a child process to 
execute the system program corresponding to the command. It should additionally interpret the 
following commands:  
o count c filename :- To print number of characters in the file. 
o count w filename  :- To print number of words in the file.  
o count 1 filename :- To print number of lines in the file. 
 
 
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
#include <stdio.h> 
#include <stdlib.h> 
#include <string.h> 
 
void make_toks(char *s, char *tok[]) 
{ 
 int i=0; 
 char *p; 
 
 p = strtok(s," "); 
 while(p!=NULL) 
 { 
  tok[i++]=p; 
  p=strtok(NULL," "); 
 } 
 
 tok[i]=NULL; 
} 
 
void count(char *fn, char op) 
{ 
 int fh,cc=0,wc=0,lc=0; 
 char c; 
 
 fh = open(fn,O_RDONLY); 
 if(fh==-1) 
 { 
  printf("File %s not found.\n",fn); 
  return; 
 } 
 
 while(read(fh,&c,1)>0) 
 { 
  if(c==' ') wc++; 
  else if(c=='\n') 
  { 
   wc++; 
   lc++; 
  } 
  cc++; 
 } 
 
 close(fh); 
 
 switch(op) 
 { 
 case 'c': 
  printf("No.of characters:%d\n",cc); 
  break; 
 case 'w': 
  printf("No.of words:%d\n",wc); 
  break; 
 case 'l': 
  printf("No.of lines:%d\n",lc); 
  break; 
 } 
} 
 
int main() 
{ 
 char buff[80],*args[10]; 
 int pid; 
 
 while(1) 
 { 
  printf("myshell$"); 
  fflush(stdin); 
  fgets(buff,80,stdin); 
  buff[strlen(buff)-1]='\0'; 
  make_toks(buff,args); 
  if(strcmp(args[0],"count")==0) 
   count(args[2],args[1][0]); 
  else 
  { 
   pid = fork(); 
   if(pid>0) 
    wait(); 
   else 
   { 
    if(execvp(args[0],args)==-1) 
     printf("Bad command.\n"); 
   } 
  } 
 } 
 
 return 0; 
} 
 
 
Write a simulation program to implement non-pre-emptive Priority CPU scheduling algorithm. Accept 
the number of Processes and arrival time, CPU burst time and priority for each process as input. 
Priorities should in High to Low order (1 is High). The output should give the Gantt chart, turnaround 
time and waiting time for each process. Also display the average turnaround time and average 
waiting time 
#include<stdio.h> 
#include<stdlib.h> 
#include<string.h> 
 
typedef struct process_info 
{ 
 char pname[20]; 
 int at,bt,ct,bt1,p; 
 struct process_info *next; 
}NODE; 
 
int n; 
NODE *first,*last; 
 
void accept_info() 
{ 
 NODE *p; 
 int i; 
 
 printf("Enter no.of process:"); 
 scanf("%d",&n); 
 
 for(i=0;i<n;i++) 
 { 
  p = (NODE*)malloc(sizeof(NODE)); 
 
  printf("Enter process name:"); 
  scanf("%s",p->pname); 
 
  printf("Enter arrival time:"); 
  scanf("%d",&p->at); 
 
  printf("Enter first CPU burst time:"); 
  scanf("%d",&p->bt); 
 
  printf("Enter priority:"); 
  scanf("%d",&p->p); 
 
  p->bt1 = p->bt; 
   
  p->next = NULL; 
 
  if(first==NULL) 
   first=p; 
  else 
   last->next=p; 
 
  last = p; 
 } 
} 
 
void print_output() 
{ 
 NODE *p; 
 float avg_tat=0,avg_wt=0; 
 
 printf("pname\tat\tbt\tp\ttct\ttat\twt\n"); 
 
 p = first; 
 while(p!=NULL) 
 { 
  int tat = p->ct-p->at; 
  int wt = tat-p->bt; 
   
  avg_tat+=tat; 
  avg_wt+=wt; 
 
  printf("%s\t%d\t%d\t%d\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt,p->p,p->ct,tat,wt); 
   
  p=p->next; 
 } 
 
 printf("Avg TAT=%f\tAvg WT=%f\n", 
   avg_tat/n,avg_wt/n); 
} 
 
void print_input() 
{ 
 NODE *p; 
 
 p = first; 
  
 printf("pname\tat\tbt\tp\n"); 
 while(p!=NULL) 
 { 
  printf("%s\t%d\t%d\t%d\n", 
   p->pname,p->at,p->bt1,p->p); 
  p = p->next; 
 } 
} 
 
void sort() 
{ 
 NODE *p,*q; 
 int t; 
 char name[20]; 
 
 p = first; 
 while(p->next!=NULL) 
 { 
  q=p->next; 
  while(q!=NULL) 
  { 
   if(p->at > q->at) 
   { 
    strcpy(name,p->pname); 
    strcpy(p->pname,q->pname); 
    strcpy(q->pname,name); 
 
    t = p->at; 
    p->at = q->at; 
    q->at = t; 
     
    t = p->bt; 
    p->bt = q->bt; 
    q->bt = t; 
 
    t = p->ct; 
    p->ct = q->ct; 
    q->ct = t; 
 
    t = p->bt1; 
    p->bt1 = q->bt1; 
    q->bt1 = t; 
    
    t = p->p; 
    p->p = q->p; 
    q->p = t; 
   } 
 
   q=q->next; 
  } 
  
  p=p->next; 
 } 
} 
 
int time; 
 
NODE * get_p() 
{ 
 NODE *p,*min_p=NULL; 
 int min=9999; 
 
 p = first; 
 while(p!=NULL) 
 { 
  if(p->at<=time && p->bt1!=0 && 
   p->p<min) 
  { 
   min = p->p; 
   min_p = p; 
  } 
  p=p->next; 
 } 
 
 return min_p; 
} 
 
struct gantt_chart 
{ 
 int start; 
 char pname[30]; 
 int end; 
}s[100],s1[100]; 
 
int k; 
 
void pnp() 
{ 
 int prev=0,n1=0; 
 NODE *p; 
 
 while(n1!=n) 
 { 
  p = get_p(); 
 
  if(p==NULL) 
  { 
   time++; 
   s[k].start = prev; 
   strcpy(s[k].pname,"*"); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
  } 
  else 
  { 
   time+=p->bt1; 
   s[k].start = prev; 
   strcpy(s[k].pname, p->pname); 
   s[k].end = time; 
 
   prev = time; 
   k++; 
 
   p->ct = time; 
   p->bt1 = 0; 
 
   n1++; 
  } 
 
  print_input();  
  sort(); 
 } 
} 
 
void print_gantt_chart() 
{ 
 int i,j,m; 
 
 s1[0] = s[0]; 
  
 for(i=1,j=0;i<k;i++) 
 { 
  if(strcmp(s[i].pname,s1[j].pname)==0) 
   s1[j].end = s[i].end; 
  else 
   s1[++j] = s[i]; 
 } 
 
 printf("%d",s1[0].start); 
 for(i=0;i<=j;i++) 
 { 
  m = (s1[i].end - s1[i].start); 
 
  for(k=0;k<m/2;k++) 
   printf("-"); 
 
  printf("%s",s1[i].pname); 
 
  for(k=0;k<(m+1)/2;k++) 
   printf("-"); 
 
  printf("%d",s1[i].end); 
 } 
} 
 
int main() 
{ 
accept_info(); 
sort(); 
pnp(); 
print_output(); 
print_gantt_chart(); 
return 0; 
} 
Write a program to implement a Banker‟s Algorithm. Accept the total number of processes (n) and 
resource types (m) as input. Also accept the number of initial instances for each resource type. 
Allocation and Max of size “nxm” as input and perform the following operations: 
o a) Calculate and display the final contents of Available array of size “m” 
o b) Calculate and display the contents of Need matrix of size “nxm” 
o Using Safety and Resource-Request algorithm perform the following operations: 
o a) Check whether system is in safe sate or not.  
o b) If request of size “m” arrives from process Pi, can it be granted immediately by 
keeping system in safe state? 
#include<stdio.h> 
#define MAX 10 
int m,n,total[MAX],avail[MAX],alloc[MAX][MAX], 
max[MAX][MAX],need[MAX][MAX],work[MAX],finish[MAX], 
seq[MAX],request[MAX]; 
void accept() 
{ 
int i,j; 
printf("Enter no.of process:"); 
scanf("%d",&n); 
printf("Enter no.of resource types:"); 
scanf("%d",&m); 
printf("Enter total no.of resources of each resource type:\n"); 
for(i=0;i<m;i++) 
{ 
printf("%c:",65+i); 
scanf("%d",&total[i]); 
} 
 printf("Enter no.of allocated resources of each resource type by each process:\n"); 
 
 for(i=0;i<n;i++) 
 { 
  printf("P%d:\n",i); 
  for(j=0;j<m;j++) 
  { 
   printf("%c:",65+j); 
   scanf("%d",&alloc[i][j]); 
  } 
 } 
 
 printf("Enter no.of maximum resources of each resource type by each process:\n");    
  
 for(i=0;i<n;i++) 
 { 
  printf("P%d:\n",i); 
  for(j=0;j<m;j++) 
  { 
   printf("%c:",65+j); 
   scanf("%d",&max[i][j]); 
  } 
 } 
} 
 
void calc_avail() 
{ 
 int i,j,s; 
 
 for(j=0;j<m;j++) 
 { 
  s=0; 
  for(i=0;i<n;i++) 
   s+=alloc[i][j]; 
 
  avail[j] = total[j] - s; 
 } 
} 
 
void calc_need() 
{ 
 int i,j; 
 
 for(i=0;i<n;i++) 
  for(j=0;j<m;j++) 
   need[i][j]=max[i][j]-alloc[i][j]; 
} 
 
void print() 
{ 
 int i,j; 
  
 printf("\tAllocation\tMax\tNeed\n\t"); 
 
 for(i=0;i<3;i++) 
 { 
  for(j=0;j<m;j++) 
   printf("%3c",65+j); 
  printf("\t"); 
 } 
 
 printf("\n"); 
 for(i=0;i<n;i++) 
 { 
  printf("P%d\t",i); 
  for(j=0;j<m;j++) 
   printf("%3d",alloc[i][j]); 
  printf("\t"); 
  for(j=0;j<m;j++) 
   printf("%3d",max[i][j]); 
  printf("\t"); 
  for(j=0;j<m;j++) 
   printf("%3d",need[i][j]); 
  printf("\n"); 
 } 
 
 printf("Available\n"); 
 for(j=0;j<m;j++) 
  printf("%3c",65+j); 
 printf("\n"); 
 for(j=0;j<m;j++) 
  printf("%3d",avail[j]); 
 
 printf("\n"); 
} 
 
int check(int s) 
{ 
 int i,j; 
 
 i = s; 
 do 
 { 
  if(!finish[i]) 
  { 
   for(j=0;j<m;j++) 
   { 
    if(need[i][j]>work[j]) 
     break; 
   } 
    
   if(j==m) return i; 
  } 
 
  i=(i+1)%n; 
 }while(i!=s); 
 
 return -1; 
} 
 
void banker() 
{ 
 int i,j,k=0; 
 
 for(i=0;i<n;i++) 
  finish[i]=0; 
 
 for(j=0;j<m;j++) 
  work[j] = avail[j]; 
 
 i=0; 
 while((i=check(i))!=-1) 
 { 
  printf("Process P%d resource granted.\n",i); 
  finish[i] = 1; 
   
  for(j=0;j<m;j++) 
   work[j] += alloc[i][j]; 
  
  printf("finish("); 
  for(j=0;j<n;j++) 
   printf("%d,",finish[j]); 
  printf("\b)\nwork("); 
  for(j=0;j<m;j++) 
   printf("%d,",work[j]); 
  printf("\b)\n"); 
 
  seq[k++]=i; 
  
  i=(i+1)%n; 
 } 
 
 if(k==n) 
 { 
  printf("System is in safe state.\n"); 
  printf("Safe sequence:"); 
  for(j=0;j<n;j++) 
   printf("P%d ",seq[j]); 
 } 
 else 
 { 
  printf("System is not in safe state."); 
 } 
 printf("\n"); 
} 
 
int main() 
{ 
 int i,j,pno; 
 
 accept(); 
 calc_avail(); 
 calc_need(); 
 print(); 
 banker(); 
 
 printf("Enter process no:"); 
 scanf("%d",&pno); 
 
 printf("Enter resource request of process P%d\n",pno); 
 
 for(j=0;j<m;j++) 
 { 
  printf("%c:",65+j); 
  scanf("%d",&request[j]); 
 } 
 
 for(j=0;j<m;j++) 
 { 
  if(request[j]>need[pno][j]) 
   break; 
 } 
 
 if(j==m) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(request[j]>avail[j]) 
    break; 
  } 
 
  if(j==m) 
  { 
   for(j=0;j<m;j++) 
   { 
    avail[j]-=request[j]; 
    alloc[pno][j]+=request[j]; 
    need[pno][j]-=request[j]; 
    print(); 
    banker(); 
   } 
  } 
  else 
   printf("Process P%d must wait.\n",pno); 
 } 
 else 
  printf("Process P%d has exceeded its maximum claim\n",pno); 
 
 return 0; 
} 
 
Consider the following snapshot of the system  
  Calculate and display the contents of matrix Need. Using Safety and Resource-RequestAlgorithm 
perform the following operations: 
o Check whether the current system is in safe state or not. 
o If a request from process P4 arrives as (0, 0, 4, 1), can it be granted immediately by 
keeping system in safe state.  
 
#include<stdio.h> 
#define MAX 10 
 
int m,n,total[MAX],avail[MAX],alloc[MAX][MAX], 
    max[MAX][MAX],need[MAX][MAX],work[MAX],finish[MAX], 
    seq[MAX],request[MAX]; 
 
void accept() 
{ 
 int i,j; 
 
 printf("Enter no.of process:"); 
 scanf("%d",&n); 
 
 printf("Enter no.of resource types:"); 
 scanf("%d",&m); 
 
 printf("Enter total no.of resources of each resource type:\n"); 
 
 for(i=0;i<m;i++) 
 { 
  printf("%c:",65+i); 
  scanf("%d",&total[i]); 
 } 
 
 printf("Enter no.of allocated resources of each resource type by each process:\n"); 
 
 for(i=0;i<n;i++) 
 { 
  printf("P%d:\n",i); 
  for(j=0;j<m;j++) 
  { 
   printf("%c:",65+j); 
   scanf("%d",&alloc[i][j]); 
  } 
 } 
 
 printf("Enter no.of maximum resources of each resource type by each process:\n");    
  
 for(i=0;i<n;i++) 
 { 
  printf("P%d:\n",i); 
  for(j=0;j<m;j++) 
  { 
   printf("%c:",65+j); 
   scanf("%d",&max[i][j]); 
  } 
 } 
} 
 
void calc_avail() 
{ 
 int i,j,s; 
 
 for(j=0;j<m;j++) 
 { 
  s=0; 
  for(i=0;i<n;i++) 
   s+=alloc[i][j]; 
 
  avail[j] = total[j] - s; 
 } 
} 
 
void calc_need() 
{ 
 int i,j; 
 
 for(i=0;i<n;i++) 
  for(j=0;j<m;j++) 
   need[i][j]=max[i][j]-alloc[i][j]; 
} 
 
void print() 
{ 
 int i,j; 
  
 printf("\tAllocation\tMax\tNeed\n\t"); 
 
 for(i=0;i<3;i++) 
 { 
  for(j=0;j<m;j++) 
   printf("%3c",65+j); 
  printf("\t"); 
 } 
 
 printf("\n"); 
 for(i=0;i<n;i++) 
 { 
  printf("P%d\t",i); 
  for(j=0;j<m;j++) 
   printf("%3d",alloc[i][j]); 
  printf("\t"); 
  for(j=0;j<m;j++) 
   printf("%3d",max[i][j]); 
  printf("\t"); 
  for(j=0;j<m;j++) 
   printf("%3d",need[i][j]); 
  printf("\n"); 
 } 
 
 printf("Available\n"); 
 for(j=0;j<m;j++) 
  printf("%3c",65+j); 
 printf("\n"); 
 for(j=0;j<m;j++) 
  printf("%3d",avail[j]); 
 
 printf("\n"); 
} 
 
int check(int s) 
{ 
 int i,j; 
 
 i = s; 
 do 
 { 
  if(!finish[i]) 
  { 
   for(j=0;j<m;j++) 
   { 
    if(need[i][j]>work[j]) 
     break; 
   } 
    
   if(j==m) return i; 
  } 
 
  i=(i+1)%n; 
 }while(i!=s); 
 
 return -1; 
} 
 
void banker() 
{ 
 int i,j,k=0; 
 
 for(i=0;i<n;i++) 
  finish[i]=0; 
 
 for(j=0;j<m;j++) 
  work[j] = avail[j]; 
 
 i=0; 
 while((i=check(i))!=-1) 
 { 
  printf("Process P%d resource granted.\n",i); 
  finish[i] = 1; 
   
  for(j=0;j<m;j++) 
   work[j] += alloc[i][j]; 
  
  printf("finish("); 
  for(j=0;j<n;j++) 
   printf("%d,",finish[j]); 
  printf("\b)\nwork("); 
  for(j=0;j<m;j++) 
   printf("%d,",work[j]); 
  printf("\b)\n"); 
 
  seq[k++]=i; 
  
  i=(i+1)%n; 
 } 
 
 if(k==n) 
 { 
  printf("System is in safe state.\n"); 
  printf("Safe sequence:"); 
  for(j=0;j<n;j++) 
   printf("P%d ",seq[j]); 
 } 
 else 
 { 
  printf("System is not in safe state."); 
 } 
 printf("\n"); 
} 
 
int main() 
{ 
 int i,j,pno; 
 
 accept(); 
 calc_avail(); 
 calc_need(); 
 print(); 
 banker(); 
 
 printf("Enter process no:"); 
 scanf("%d",&pno); 
 
 printf("Enter resource request of process P%d\n",pno); 
 
 for(j=0;j<m;j++) 
 { 
  printf("%c:",65+j); 
  scanf("%d",&request[j]); 
 } 
 
 for(j=0;j<m;j++) 
 { 
  if(request[j]>need[pno][j]) 
   break; 
 } 
 
 if(j==m) 
 { 
  for(j=0;j<m;j++) 
  { 
   if(request[j]>avail[j]) 
    break; 
  } 
 
  if(j==m) 
  { 
   for(j=0;j<m;j++) 
   { 
    avail[j]-=request[j]; 
    alloc[pno][j]+=request[j]; 
    need[pno][j]-=request[j]; 
    print(); 
    banker(); 
   } 
  } 
  else 
   printf("Process P%d must wait.\n",pno); 
 } 
else 
printf("Process P%d has exceeded its maximum claim\n",pno); 
return 0; 
} 
